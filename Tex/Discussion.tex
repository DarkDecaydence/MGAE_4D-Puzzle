\section{Discussion}
Throughout our project, multiple choices were made to further development. In this section, we will discuss alternatives to our chosen solutions.

\subsection{4D-transformations and -movement}
Instead of moving between points on the fourth dimension, we could instead have used a more fluid movement system, which we considered during the first week of development. This approach lends much more freedom to the player, and creates a true 4D environment, which in design terms better communicate our chosen message.\\

Fluid movement would mean less replication of environments, but more complex collision calculations. The trade-off here would be hard to measure concretely, since a fluid collision detection system was never implemented properly, but it would apply pressure to the algorithms instead of the object count. Additionally, only one complex collision detection algorithm would be necessary, instead of the multiple simple ones needed as part of composite objects used in our final solution.\\

This movement could include correct mathematical rotation around all geometric planes, with resulting complicated, yet interesting, puzzle and game play opportunities. One could argue these transformations would be unnecessary from a design perspective, given their overly complex and incomprehensible nature.\\

While a technically interesting challenge, the design itself would be a struggle of understanding and applying mathematical concepts to properly fit a game play in which it could become highly unnecessary. The approach we used lends itself especially well to game play due to its relative ease of understanding and appliance, two qualities which the fluid solution does not possess.

\subsection{Transparency of 4D objects}
We decided to use transparency as a means to visualize the fourth dimension, which is handled by the standard shader Unity uses. Within the shader, options are changed when the player moves along the fourth dimension. This enables objects to become opaque or fully transparent, depending on the object's relative distance (on the W-axis) to the player character.\\

Our implementation does need some optimization. Currently, the materials have their colour changed such that the transparency applies, but this does not exclude even fully transparent objects from being drawn during rendering passes. Unity also needs every object to be non-static in order to change the rendering options correctly, which prevents us from using occlusion culling.\\

Due to the way Unity handles rendering passes, the problems could be mended by systematically changing the properties of materials that appear in each environment. Additionally, a custom shader or likewise implementation could be used to skip the rendering passes of the completely invisible meshes, drastically reducing the amount of rendered polygons within a scene.\\